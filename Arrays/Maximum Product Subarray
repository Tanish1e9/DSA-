LC link: https://leetcode.com/problems/maximum-product-subarray/description/

// Dekh isme na sabse pehle to maan lo ki saare elements non-zero h
// ab socho ans kaise niklega
// to at any index i, max product subarray ending at i kya hoga?
// agar nums[i] < 0 h, to hm chahenge i-1 to 0 jaye aur jitna jada negative product ho le aaye,
// jisse multiply hoke positive ban jayega
// agar nums[i] > 0 h, to hm chahenge ki i-1 to 0 jaaye aur jitna jada positive element ho le aaye
// jisse multiply hoke positive ban jayega
// to like har index pe max positive, min negative product store krne se kaam chal jayega
// Now introduce 0, koi nums[i] agar 0 ho gya to max pos/ min neg at index i to zero hi ho jayega
// to agla element ko ek tarah se rokna padega 0 ko cross krne se agar wo non-zero h to
// to islie ye choice die h ki har index pe ya to element ko alone le lo, ya piche k sath combine kro
// DP idea likha hai yaha pe look for cleaner code below it

int maxProduct(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> dp(n, vector<int>(2, 0));
    // 0 means non-negative
    // 1 means negative (agar not possible to 0 rhega)
    int ans = nums[0];
    
    dp[0][0] = max(dp[0][0], nums[0]);
    dp[0][1] = min(dp[0][1], nums[0]);

    for(int i=1;i<n;i++) {
        if(nums[i] < 0) {
            dp[i][0] = max(nums[i] * dp[i-1][1], nums[i]);
            dp[i][1] = min(nums[i] * dp[i-1][0], nums[i]);
        } else {
            dp[i][0] = max(nums[i] * dp[i-1][0], nums[i]);
            dp[i][1] = min(nums[i] * dp[i-1][1], nums[i]);
        }
        ans = max(ans, dp[i][1]);
        ans = max(ans, dp[i][0]);
    }
    return ans;
}




// Cleaner code
// Kisi bhi index pe suppose piche wale index me maxi = 0 and mini = 0 hai
// to apne aap hi agar current element positive h, to maxi me curr_element jana chahye aur mini me 0,
// ye hoga hi na dekh lo expressions
// same case agar element negative h aur piche mini = 0, ya maxi = 0 hai
// to maxi me 0 aur mini me nums[i] jana chahye wo jayega hi na

int maxProduct(vector<int>& nums) {
    int n = nums.size();
    int maxi = 0, mini = 0;
    
    maxi = max(0, nums[0]);
    mini = min(0, nums[0]);
    int ans = nums[0];

    for(int i=1;i<n;i++) {
        if(nums[i] < 0) {
            int temp = mini;
            mini = min(maxi * nums[i], nums[i]);
            maxi = max(temp * nums[i], nums[i]);
        }
        else {
            maxi = max(maxi * nums[i], nums[i]);
            mini = min(mini * nums[i], nums[i]);
        }
        ans = max(ans, maxi);
    }
    return ans;
}



// Pure observation based code... Case bana ki (saare positive) h ya (even negatives, rest positive) h
// in cases me to sara array ka product hi ans hoga... 
// ab agar odd negatives ho... to socho koi ek negative ko hatana hoga... to first ya last negative ko hi hatayenge na
// to prefix ya suffix hi to ans hua...
// ab include kro zeros ko... to soch ki yar 0's ko kaatke... subarrays ban jayenge na... usme wapas se ye prefix ya suffix
// ka khela hoga... islie pre ya suf jab bhi 0 hit kre unko 1 kr dena

int maxProduct(vector<int>& nums) {
    int ans = -1e9;
    int pre = 1, suf = 1;
    int n = nums.size();
    for(int i=0;i<n;i++) {
        if(pre == 0) pre = 1;
        if(suf == 0) suf = 1;

        pre = pre * nums[i];
        suf = suf * nums[n-1-i];
        ans = max({ans, pre, suf});
    }
    return ans;
}
