CodeChef link: 

// ye to simple hi tha
// agar extra edge na ho tab to path weight nikalne tk standard binary lifting hi lagega bas ek weights array 
// (jo ki root to har node ka sum of weights store krega usko maintain krna hoga)
// aur fir ek dusre path ke lie subtree me highest weighted path le lena h
// 0 se bada hi lenge negative leke koi fayda nahi
// Literally isme endl daal dene se TLE maar rha tha

#include <bits/stdc++.h>
using namespace std;
#define int long
void dfs(int root, auto &adj, auto &parent, auto &weights, auto &level, auto &sub_weights){
    int val = 0;
    for(auto el:adj[root]) {
        if(level[el.first]!=-1) continue;
        parent[0][el.first] = root;
        weights[el.first] = weights[root] + el.second;
        level[el.first] = level[root] + 1;
        dfs(el.first, adj, parent, weights, level, sub_weights);
        val = max(sub_weights[el.first]+el.second, val);
    }
    sub_weights[root] = val;
}
void populate_parent(int n, auto &parent){
	int k = 1;
	while((1<<k)<=n) {
    	for(int i=2;i<=n;i++){
			int mid = parent[k-1][i];
			if(mid!=-1) parent[k][i] = parent[k-1][mid];
		}
		k++;
	}
}
int lca(int n, int u,int v, auto &parent, auto &level){
    int lu = level[u];
    int lv = level[v];
    if(lu>lv) return lca(n,v,u,parent,level);
    int diff = lv - lu;
    for(int i=17;i>=0;i--) {
        if(v==-1) break;
        if(diff & (1<<i)) v = parent[i][v];
    }
    if(u==v) return u;
    int up = u;
    int vp = v;
    for(int i=17;i>=0;i--){
        up = parent[i][u];
        vp = parent[i][v];
        if(up!=vp) {
            v = vp;
            u = up;
        }
    }
    return parent[0][u];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int t;
	cin >> t;
	while(t--) {
	    int n, q;
	    cin >> n >> q;
    	vector<vector<pair<int,int>>> adj(n+1);
	    for(int i=0;i<n-1;i++){
	        int u,v,w;
	        cin >> u >> v >> w;
	        adj[u].push_back({v,w});
	        adj[v].push_back({u,w});
	    }
	    vector<vector<int>> parent(18, vector<int>(n+1, -1));
	    vector<int>weights(n+1, -1);
	    vector<int>level(n+1, -1);
	    vector<int>sub_weights(n+1, 0);
	    weights[1] = 0;
	    level[1] = 0;
	    dfs(1, adj, parent, weights, level, sub_weights);
	    populate_parent(n, parent);
	    while(q--) {
	        int u,v,x;
	        cin >> u >> v >> x;
	        int lc = lca(n,u,v,parent,level);
	        cout << max(weights[u] + weights[v] - 2*weights[lc], sub_weights[u] + sub_weights[v] + x) << "\n";
	    }
	}
	return 0;
}
