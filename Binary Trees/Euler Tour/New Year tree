CF link: https://codeforces.com/contest/620/problem/E

#include <bits/stdc++.h>
using namespace std;
#define int long long
void dfs(int root, int par, auto &adj, int &time, auto &tour, auto &time_start, auto &time_end, auto &colours) {
	time++;
	time_start[root] = time;
	tour[time] = colours[root];
	for(int el:adj[root]) {
		if(el==par) continue;
		dfs(el, root, adj, time, tour, time_start, time_end, colours);
	}
	time_end[root] = time;
}
class seg_tree{
	public:
	vector<int> seg, lazy;
	// seg[ind] will store ki kon-kon se colour h uss range me
	// by setting that bit to 1
	seg_tree(vector<int>&tour) {
		int n=tour.size();
		seg = vector<int>(4*n+1,0);
		lazy = vector<int>(4*n+1,0);
		build(0,0,n-1,tour);
	}
	void build(int ind, int low, int high, auto &tour){
		if(low == high) {
			seg[ind] = (1ll << tour[low]);
			return;
		}
		int mid = low + (high - low)/2;
		build(2*ind+1, low, mid, tour);
		build(2*ind+2, mid+1, high, tour);
		seg[ind] = seg[2*ind+1] | seg[2*ind+2];
	}
	void update(int ind, int low, int high, int l, int r, int c) {
		// ye lazy updates na pehle hi krna jroooooooooooooooooooooooori hai
		// because ki ho skta h partial overlap ho aur aise child me aa gye jiska ki requested range se mtlb nhi h
		// par isme kuch lazy pada ho to usko to update krna hoga na
		// kyunki fir usse upar wale ka ans affect hoga
		if(lazy[ind]!=0) {
			seg[ind] = lazy[ind];
			if(low!=high) {
				lazy[2*ind + 1] = lazy[ind];
				lazy[2*ind + 2] = lazy[ind];
			}
			lazy[ind] = 0;
		}
		if(r<low || l>high) return;
		if(l <= low && high <= r) {
			seg[ind] = (1ll << c);
			if(low!=high) {
				lazy[2*ind + 1] = 1ll << c;
				lazy[2*ind + 2] = 1ll << c;
			}
			return;
		}
		int mid = low + (high - low)/2;
		update(2*ind+1, low, mid, l, r, c);
		update(2*ind+2, mid+1, high, l, r, c);
		seg[ind] = seg[2*ind+1] | seg[2*ind+2];
	}
	int query(int ind, int low, int high, int l, int r) {
		// ye lazy updates na pehle hi krna jroooooooooooooooooooooooori hai
		// because ki ho skta h partial overlap ho aur aise child me aa gye jiska ki requested range se mtlb nhi h
		// par isme kuch lazy pada ho to usko to update krna hoga na
		// kyunki fir usse upar wale ka ans affect hoga
		if(lazy[ind]!=0) {
			seg[ind] = lazy[ind];
			if(low!=high) {
				lazy[2*ind+1] = lazy[ind];
				lazy[2*ind+2] = lazy[ind];
			}
			lazy[ind] = 0;
		}
		if(l>high || r <low) return 0;
		if(l<=low && high<=r) return seg[ind];
		int mid = low + (high - low)/2;
		int left = query(2*ind+1, low, mid, l, r);
		int right = query(2*ind+2, mid+1, high, l, r);
		return left | right;
	}
};
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, m;
	cin >> n >> m;
	vector<vector<int>> adj(n+1);
	vector<int> colours(n+1), time_end(n+1), time_start(n+1), tour(n);
	for(int i=1;i<=n;i++){
		cin >> colours[i];
	}
	for(int i=0;i<n-1;i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	int time = -1;
	dfs(1, -1, adj, time, tour, time_start, time_end, colours);
	seg_tree s1(tour);
	while(m--) {
		int type;
		cin >> type;
		if(type == 1) {
			int v, c;
			cin >> v >> c;
			s1.update(0,0,n-1,time_start[v],time_end[v],c);
		} else {
			int v;
			cin >> v;
			int val = s1.query(0,0,n-1,time_start[v],time_end[v]);
			int ans = 0;
			while(val) {
				ans++;
				val = val & (val-1);
			}
			cout << ans << "\n";
		}
	}
	return 0;
}
