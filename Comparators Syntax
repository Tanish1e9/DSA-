class comp{
    public:
	// ye jo args k pehle const h na (set aur map me jroori h since keys must not change, but PQ me aisa ni h)
	// Nevertheless, sab jagah const likhna faydemand hi h
    bool operator()(const T&a,const T&b)const{
        return a->val < b->val;
    }//Note that priority queue me comparator min heap implementation me hi jata h to yaha soch rhe hoge increasing order me ayega but 
    // ulta hoga decreasing order me aa jayega
    // const likh dia krna kahi kahi error aa jata h
};
int main(){
    sort(arr.begin(),arr.end(),comp());        // sort me dekho class daalna ho to () laga dena end me bas
    // baaki normal static bool function to bana hi skte ho wo to malum hi h sort k lie
    priority_queue<T,vector<T>,comp>pq;
    map<T,V,comp> mp;
	// set/map ke case me comparator dhyan se likhna since keys waha pe unique hote h
	// to agar sirf a.first < b.first kr dia to (5,3), (5,4) ko same maanke ek ko hata dia jayega which we dont want
    set<T,comp> s;
    return 0;
}

// Agar koi aur variable capture krna ho to aise krna
class comp{
	public:
	vector<int> distances;
	comp(vector<int>&d) {
		distances = d;
	}
	bool operator()(int a, int b) const {
		return distances[a] > distances[b];
	}
};
// dhyan se parantheses dekh lo aise hi teen lagenge
priority_queue<T,vector<T>,comp>pq((comp(distances)));

// comparator ke kuch rules h
- comp(a, a) must be false
- if comp(a, b) is true => comp(b, a) is false
- comp is transitive

------------- islie kabhi bhi a<=b type ka comparator mat likhna (a<b) hi likho bas
(This can make difference between TLE and accepted)


Or we can do through lambda functions

auto comp = [](T&a,T&b)->bool{
    return a->val < b->val;
    // same thing ulta ayega since min heap h
};
sort(arr.begin(),arr.end(),comp);        // dekho sort me decltype ni likhna h
priority_queue<T,vector<T>,decltype(comp)> pq(comp;
map<T,V,decltype(comp)> mp;
set<T,decltype(comp)> s;

// Agar T jo ho wo Node* ho to & lagane se shyd kahi error de skta h to & mat lagana
is_sorted(vec.begin(),vec.end());    // krke use kr skte ho
// gcd , lcm functions hote h numeric library me builtin

endl is slow kyunki wo buffer ko khaali krta h
islie agar sirf new line deni ho bhut baar to \n use krna wrna TLE bhi aa skta h
BTW, kabhi buffered output dena ho to 
ostringstream out;
out << "wgref" << "\n";
cout << out.str(); (at the end)

// also to optimise hashing we can write mpp.reserve(1<<20) isse utne keys k lie hashing optimise ho jayega
// mod ke lie ya to const int ya MACRO ..... dont declare it as normal int wrna TLE aa skta

// Kabhi reverse iterator(map) se delete krna ho
// then ye line likho 
// basically reverse iterator pe .base() krne se next element aata "forward" sense me
// so next(l).base() krne se wahi element aa jayega jispe l point kr rha tha par forward iterator hoga wo
// now we call erase 
// ab forward iterator mila usko wapas reverse iterator banana h aur ek pehle wale element ka banana h
// this is handled automatically by the constructor of reverse iterator to bas decltype(l) se kr die 
// decltype(l) is map<int,int>::reverse_iterator
l = decltype(l)( a.erase(next(l).base()) );


// Aise likhte h lower bound me comparator ... const lagana hoga ... aur jis type ke array me elements h
// usi type ka banake daalna hoga ... to dummy values daal do aur comparator sahi se likh do
static bool comp(const pair<int,int> &a, const pair<int,int> &b) {
	return a.first < b.first;
}
int idx = lower_bound(nums.begin(), nums.end(), make_pair(nums[jagah[i]].first, -1), comp) - nums.begin();

string ke end me ek character daalna ho to 
- s.push_back('c')    
- s += 'c'
dono hi O(1) hai par push_back use krna best h

string ke end me string append krna ho to 
s+= "hello" or s+=t
ye jo h O(t) hoga s ke lie in place rhta
but agar s = s+t kr dia to pura s copy hota ek temporary string banta h and wapas assign hota
to n^2 chala ja skta h agar baar baar kro to islie +=
