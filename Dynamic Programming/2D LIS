Spoj link: https://www.spoj.com/problems/LIS2/

// Dekh intuition bilkul 1D LIS ke jaisa h
// waha bhi har element pe ending max LIS length milta tha
// ab hmlog soche ki same LIS length pe chota element ko sirf store krna
// hi faydemand h... usi tarah se yaha socho ki ek hi LIS length pe
// kinko store kre? aise points jinka x aur y dono hi kisi dusre point ke x,y se
// respectively agar chota ho, to pehla point dominate kr dega second point ko
// to yaha se hi increasing x aur decreasing y ke form me points store honge aisa
// intuition aayega
// to ab ye staircase problem se thoda sa hint leke set banana h pata chala
// ab insert krne ke pehle check krenge ki kya ye point kisi aur se dominated h
// to dominated point ka x should be <= p.x and same for y
// to islie upper bound -1 krke aur y check kr dia
// agar dominated h to return kr jao (insert nahi krna)
// else insert to krenge
// ab ye check krna ki current point kinko dominate kr rha
// to ye >= p.x and >= p.y waalo ko dominate krega
// To wahi kr die h bas... Accha problem tha ye... spent a lot of time
// and finally cracked it... ekdum Russian doll aur iska solution na
// develop kie h bits and pieces me... fir itna optimal bana finally


#include<bits/stdc++.h>
using namespace std;
#define int long long

const int INF = 1e18;
bool check(auto &bucket, auto &point) {
	auto it = bucket.lower_bound(make_pair(point.first,-INF));
	if(it!=bucket.begin()) {
		it--;
		return it->second < point.second;
	}
	return false;
}
int get_bucket_index(auto &arr, auto &point) {
	int low = 0;
	int high = arr.size()-1;
	while(low<=high) {
		int mid = low + (high-low)/2;
		if(check(arr[mid], point)) low = mid+1;
		else high = mid-1;
	}
	return high;
}
void insert_to_bucket(auto &st, auto &point) {
	// checking if the point to be inserted is dominated by some point in the set
	auto it = st.upper_bound(make_pair(point.first,INF));
	if(it!=st.begin()) {
		it--;
		if(it->second <= point.second) return;
	}

	// If not then the point has to be inserted, now we will delete those points
	// which are being dominated by this point
	it = st.lower_bound(make_pair(point.first,-INF));
	while(it!=st.end() && it->second >= point.second) {
		st.erase(it);
		it = st.lower_bound(make_pair(point.first,-INF));
	}
	st.insert(point);
}
int maxEnvelopes(vector<pair<int,int>>& nums) {
	int n = nums.size();
	vector<set<pair<int,int>>> arr;
	for(int i=0;i<n;i++) {
		int idx = get_bucket_index(arr, nums[i]);
		if(idx+1 == arr.size()) arr.push_back(set<pair<int,int>>());
		insert_to_bucket(arr[idx+1], nums[i]);
	}
	return arr.size();
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	vector<pair<int,int>> arr(n);
	for(int i=0;i<n;i++) {
		cin >> arr[i].first >> arr[i].second;
	}
	cout << maxEnvelopes(arr) << endl;
	
	return 0;
}
