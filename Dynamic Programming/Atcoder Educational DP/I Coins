// Target sum jaisa hi h ab isko tabulation space optimisation sab kr lena but basic idea dekh le yahi h

// M-1: Yaha exact heads ke hisab se code likha gya h
#include<bits/stdc++.h>
using namespace std;
#define int long long
double f(int i,int heads,auto&arr,auto&memo){
	if(i==0){
		if(heads>1) return 0;
		if(heads==1) return arr[i];
		return 1-arr[i];
	}
	if(memo[i][heads]!=-1) return memo[i][heads];
	double pick = 0;
	if(heads>0) pick = arr[i]*f(i-1,heads-1,arr,memo);
	double npick = (1-arr[i])*f(i-1,heads,arr,memo);
	return memo[i][heads]=pick+npick;
}
double func(auto&arr){
	int n=arr.size();
	vector<vector<double>> memo(n,vector<double>(n+1,-1));
	double ans=0;
	for(int sum=n/2+1;sum<=n;sum++){
		ans+=f(n-1,sum,arr,memo);
	}
	return ans;
}
signed main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	int n;
	cin >> n;
	vector<double>arr(n);
	for(int i=0;i<n;i++) cin >> arr[i];
	cout << fixed << setprecision(9) << func(arr) << endl;
    return 0;
}



// M-2 Yaha atleast heads ke hisab se code likhe h
#include<bits/stdc++.h>
using namespace std;
#define int long long
double dp[3000][3000];
double helper(int i, int heads, vector<double> &arr) {
	if(i==arr.size()) {
		if(heads<=0) return 1;
		return 0;
	}
	if(dp[i][heads]!=-1) return dp[i][heads];

	double pick = arr[i] * helper(i+1, heads-1, arr);
	double npick = (1-arr[i]) * helper(i+1, heads, arr);
	return dp[i][heads] = pick + npick;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	for(int i=0;i<3000;i++) {
		fill(dp[i], dp[i]+3000, -1);
	}
	int n;
	cin >> n;
	vector<double> arr(n);
	for(int i=0;i<n;i++) {
		cin >> arr[i];
	}
	
	cout << fixed << setprecision(9) << helper(0,n/2+1, arr); << endl;
	return 0;
}




