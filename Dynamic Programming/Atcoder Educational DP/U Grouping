// Dekh isme yahi concept h na ki hm vis pass krke bata die ki kon kon se available rabbits h
// ab tm unme se kitne bhi ek group k lie chun lo and baki bache rabbits ka wapas se same function call krke maximum answer nikalwa lo
// and fir har group k across maxima leke ans aa jayega
// so scores for any mask baar baar na compute krna pade islie pehle hi precompute kr lie h computed array me
// now dekho uske baad ka jo loop h na wo jo commented h wo original h jo ki 4^n complexity chala jata
// kyunki we want to iterate over all possible submasks of all the masks
// to iss chiz ka ek beautiful optimisation h 3^n me cp algo pe jaake padhna wahi kr die h and boom accepted
// Isme na 'm' denotes the available rabbits (who have not yet been chosen) 
// Fir uska submask banake unko chun lie aisa h
// Kam se kam score 0 to ho hi skta h agar sabhi rabbits ko different groups me rakh die
// islie 0 maara h initialisation
// ab har mask m ke lie bhi agar wo pura ek group k tarah behave kre then uska score chahye hoga na we should not do this for all submasks
// rather masks k lie kr lo
// to precomputation kr skte ho but jroorat nahi h (agar submasks ko compute krna chah rhe hote then precomputation chahye but masks ke lie to nahi)
// Aur har ek mask m ka answer usse 2 chote masks par hi depend krta h
// islie increasing order me process kr rhe h
// memo[m] denotes ki m me jo bhi available rabbits h unke lie max score kya ban skta
// And also this works is ki suppose k groups me baatna optimal h for some mask
// now koi to submask aisa exist krta hoga na jo x groups ke saare rabbits ko lele
// and bache rabbits k-x groups ke ho
// yani ek tarah se groups ko disjointly baant de bas islie chal rha

#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    vector<vector<int>> arr(n, vector<int>(n));
    for(int i=0;i<n;i++) {
        for(int j=0;j<n;j++) {
            cin >> arr[i][j];
        }
    }
    vector<int> memo(1<<n, 0);
    for(int m=0;m<(1<<n);m++) {
        int score = 0;
        for(int i=0;i<n;i++) {
            if(!((1<<i) & m)) continue;
            for(int j=i+1;j<n;j++) {
                if(!((1<<j) & m)) continue;
                score += arr[i][j];
            }
        }
        memo[m] = max(memo[m], score);
        for(int s = m; s>0; s = (s-1)&m) {
            memo[m] = max(memo[m], memo[s] + memo[m^s]);
        }
    }



// M-2
// Upar wala to dekh optimal hai hi 
// but agar algorithm nahi bhi aata h na
// to bhi thoda try krte to ye accept ho jata 
// simply available rabbits ko ek vector me push krke fir uske subsets generate kra lo na
// isse ekdum 1.6s tk time chala gya limit 2s ka tha but still ye accept hua 
// Upar wala better h 50ms hi time gya h

#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    vector<vector<int>> arr(n, vector<int>(n));
    for(int i=0;i<n;i++) {
        for(int j=0;j<n;j++) {
            cin >> arr[i][j];
        }
    }
    vector<int> memo(1<<n, 0);
    for(int m=0;m<(1<<n);m++) {
        int score = 0;
        vector<int> available;
        for(int i=0;i<n;i++) {
            if(!((1<<i) & m)) continue;
            available.push_back(i);
            for(int j=i+1;j<n;j++) {
                if(!((1<<j) & m)) continue;
                score += arr[i][j];
            }
        }
        memo[m] = max(memo[m], score);
        
        int limit = (1<<available.size());
        for(int s=0;s<limit;s++) {
            int sub = 0;
            for(int j=0;j<available.size();j++) {
                if(s & (1<<j)) sub |= (1<<available[j]);
            }
            memo[m] = max(memo[m], memo[sub] + memo[m^sub]);
        }
    }

    cout << memo[(1<<n) - 1] << endl;

    return 0;
}

    cout << memo[(1<<n) - 1] << endl;

    return 0;
}
