CSES link: https://cses.fi/problemset/task/1159/

// Naive solution ki har item ko kitni bar pick kr skte uspe bhi iterate kr lo
// This is TC: O(n*x*count[i]) which is O(100*1e5*1000) = O(1e10) so we need to optimise it
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[100][100005];
int helper(int i, int x, auto &price, auto &num_pages, auto &count) {
	if(i==price.size()) return 0;
	if(dp[i][x]!=-1) return dp[i][x];
	int ans = 0;
	for(int k=0;k<=count[i];k++) {
		if(price[i]*k <= x) ans = max(ans, k*num_pages[i] + helper(i+1, x-k*price[i], price, num_pages, count));
	}

	return dp[i][x] = ans;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(dp, -1, sizeof(dp));
	int n, x;
	cin >> n >> x;
	// we want to maximise num pages within the given price x
	vector<int> price(n), num_pages(n), count(n);
	for(int i=0;i<n;i++) cin >> price[i];
	for(int i=0;i<n;i++) cin >> num_pages[i];
	for(int i=0;i<n;i++) cin >> count[i];

	cout << helper(0,x,price,num_pages,count) << endl;
	return 0;
}


// Ye accept ho gya h, but there are more techniques to learn below
// Basically, dekh pehle to pura count[i] tk enumerate kr rhe the combinations banane k lie
// but like count[i] tk ka har number banane k lie bas kuch binary bases hi to lagenge na
// to bas wahi kie h
// Yaha dhyan rakhna ki jaise jaise 2 ka powers badha rhe waise waise count se usko subtract bhi krte jana h
// This is because we want to keep the total count same, wrna to extra count aa jayega na galat ans ayega
// For eg agar kisi ka count 10 hai to isko 1,2,3,4 me split kr skte h ... but 1,2,4,8 me kr dia to galat ho jayega na
// hmlog 10 se jada wale numbers bhi bna die
// to like decomposition k lie subtract krna jroori h

#include<bits/stdc++.h>
using namespace std;
#define int long long

// int dp[1000][100005];
// This is O(n*log(ki)*x) = O(100*10*1e5) = O(1e8) this TC can pass
// but the space is not good so we should write iterative dp

// int helper(int i, int x, auto &price, auto &num_pages) {
// 	if(i==price.size()) return 0;
// 	if(dp[i][x]!=-1) return dp[i][x];
// 	int ans = helper(i+1, x, price, num_pages);
// 	if(price[i]<=x) ans = max(ans, helper(i+1, x-price[i], price, num_pages) + num_pages[i]) ;
// 	return dp[i][x] = ans;
// }
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	// memset(dp, -1, sizeof(dp));
	int n, x;
	cin >> n >> x;
	// we want to maximise num pages within the given price x
	vector<int> price(n), num_pages(n), count(n);
	for(int i=0;i<n;i++) cin >> price[i];
	for(int i=0;i<n;i++) cin >> num_pages[i];
	for(int i=0;i<n;i++) cin >> count[i];

	vector<int> upd_price, upd_num_pages;
	for(int i=0;i<n;i++) {
		int j=1;
		int c = count[i];
		while(j <= c) {
			upd_num_pages.push_back(j * num_pages[i]);
			upd_price.push_back(j * price[i]);
			c-=j;
			j*=2;
		}
		
		if(c>0) {
			upd_num_pages.push_back(c*num_pages[i]);
			upd_price.push_back(c*price[i]);
		}
	}

	// cout << helper(0,x,upd_price,upd_num_pages) << endl;
	
	vector<int> next(1e5, 0);
	int m = upd_num_pages.size();
	for(int i=0;i<m;i++) {
		for(int j=x;j>=0;j--) {
			int ans = next[j];
			if(upd_price[i] <= j) {
				ans = max(ans, next[j-upd_price[i]] + upd_num_pages[i]);
			}
			next[j] = ans;
		}
	}

	cout << next[x] << endl;

	return 0;
}


// Monotone Queue optimisation h skipping for now can read it from cp-algorithms
// Useful blogs
// https://codeforces.com/blog/entry/59606
// https://codeforces.com/blog/entry/49812
