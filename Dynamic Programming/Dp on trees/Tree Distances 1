CSES link: https://cses.fi/problemset/task/1132

// M-1 (I thought it originally)
// isme simple aisa h ki hmlog pehle subtree me jo bhi furthest node h uss hisab se kr lo dfs 
// saath me smaxi aur child (jiske through max wala path ja rha wo bhi store kro aage pata chalega kyu)
// fir ek dusra dfs krenge ki parent k through ab kya max distance h 
// agar to parent ka jo max path h wo uss child k through ni ja rha hoga then simply update kr denge child ka maxi
// else smaxi se dekhenge na
// also agar ye bhi ni chala to child ka smaxi bhi update krna hoga na
// smaxi hmesha hi max waale path jis neighbour se jayega usse nahi jayega 

#include<bits/stdc++.h>
using namespace std;
#define int long 
int mod = 1e9+7;
class info{
	public:
	int maxi = -1;
	int child = -1;
	int	smaxi = -1;
};
int dfs(int root, int par, auto &adj, auto &ans) {
	int maxi = 0;
	int smaxi = 0;
	int child = -1;
	for(int el:adj[root]) {
		if(el==par) continue;
		int val = dfs(el, root, adj, ans);
		if(val>=maxi) {
			smaxi = maxi;
			maxi = val;
			child = el;
		} else if(val>smaxi) {
			smaxi=val;
		}
	}
	ans[root].maxi = maxi;
	ans[root].child = child;
	ans[root].smaxi = smaxi;
	return maxi + 1;
}
void dfs2(int root, int par, auto &adj, auto &ans) {
	for(int el:adj[root]) {
		if(el==par) continue;
		// parent ka jo max h wo child k max se jaada hi hoga 
		// because child to abhi tk apne hi subtree me explore kia h na
		// but parent jo h wo idhar udhar bhi explore kr rakha h including the child's subtree 
		// but parent ka smax child k smax + 1 se kam bhi ho skta h because max aur smax na parent ensure krta
		// ki different children k ho 
		// to ho skta h kisi child me bhut bada smax h but still parent ka wo smax nahi hoga
		// islie we need to check ki parent ka jada h agar tabhi update kro
		// also agar child ka maxi update ho rha h then child ka smaxi is not even needed 
		// because uske kisi bhi child se collision hoga hi nahi
		// since max ka neighbour to dusre subtree me chala gya na
		// islie dekho sidhe -1 kr die h
		// yaha root bhi krna equivalent hi h -1 k jagah (no collisions in further subtrees)

		if(ans[root].child != el) {
			// ans[el].smaxi = ans[el].maxi;	// this line is not needed (explained above)
			ans[el].maxi = 1 + ans[root].maxi;
			ans[el].child = -1;		// yaha -1 or root dono hi kr skte h because we are sure ki iska max path ab 
									// iske bachho k through to nahi hi jayega to -1 hi rakh do kya fark h
		}
		else if(1+ans[root].smaxi>ans[el].maxi) {
			// ans[el].smaxi = ans[el].maxi;	// this line is not needed (explained above)
			ans[el].maxi = 1 + ans[root].smaxi;
			ans[el].child = -1; 	// yaha -1 or root dono hi kr skte h because we are sure ki iska max path ab 
									// iske bachho k through to nahi hi jayega to -1 hi rakh do kya fark h
		} 
		else if(1+ans[root].smaxi>ans[el].smaxi) ans[el].smaxi = 1 + ans[root].smaxi;
		
		dfs2(el, root, adj, ans);
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n;
	cin >> n;
	vector<vector<int>> adj(n+1);
	vector<info> ans(n+1);
	for(int i=0;i<n-1;i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	dfs(1, -1, adj, ans);
	dfs2(1, -1, adj, ans);
	for(int i=1;i<=n;i++) {
		cout << ans[i].maxi << " ";
	}
	cout << "\n";
	return 0;
}

// M-2
// Dekh diameter nikalne ka na do algorithm ek to simple h ki har child ka height nikal lo
// max + smax height is the diameter 
// dusra algo h ki koi bhi node se dfs start kro and furthest node pe pahucho (suppose b)
// then b se dfs kro and furthest node c pe pahucho
// (b,c) is a diamter 
// now diameter ko na pura horizontally rakho and let the other nodes hang from it
// dikhega ki har node ka max distance wala node ya to b h ya to c h
// to bas (jab b se dfs kr rhe the to level nikalte rhna jisse b se distances nikal jayenge)
// and jab c se kr rhe hoge to max le lena

#include<bits/stdc++.h>
using namespace std;
#define int long 
int dfs(int root, int par, auto &adj, auto &ans, int level, bool take_max=false) {
	if(take_max) ans[root] = max(ans[root], level);
	else ans[root] = level;
	int opt = root;
	for(int el:adj[root]){
		if (el == par) continue;
		int val = dfs(el, root, adj, ans, level + 1, take_max);
		if(ans[val] > ans[opt]) opt = val;
	}
	return opt;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n;
	cin >> n;
	vector<vector<int>> adj(n+1);
	vector<int> ans(n+1,-1);
	for(int i=0;i<n-1;i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	int dia_a = dfs(1, -1, adj, ans, 0);
	int dia_b = dfs(dia_a, -1, adj, ans, 0);
	dfs(dia_b, -1, adj, ans, 0, true);
	for(int i=1;i<=n;i++) {
		cout << ans[i] << " ";
	}
	cout << "\n";
	return 0;
}
