CSES link: https://cses.fi/problemset/task/1130/

#include<bits/stdc++.h>
using namespace std;
#define int long
void dfs(int root, int par, auto &adj, auto &max_matching) {
	int val = 0;
	for(int el:adj[root]) {
		if(el == par) continue;
		dfs(el, root, adj, max_matching);
		val += max(max_matching[el][0], max_matching[el][1]) ;
	}
	// not considering root
	max_matching[root][0] = val;
	for(int el:adj[root]) {
		if(el == par) continue;
		int el_contri = max(max_matching[el][0],max_matching[el][1]);
		// considering root baari baari
		max_matching[root][1] = max(max_matching[root][1], max_matching[root][0] - el_contri + 
			max_matching[el][0] + 1);
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n;
	cin >> n;
	vector<vector<int>> adj(n+1);
	// 0 denotes not taking root
	// 1 denotes taking root in some child edge
	vector<vector<int>> max_matching(n+1, vector<int>(2,0));
	for(int i=0;i<n-1;i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	dfs(1, -1, adj, max_matching);
	cout << max(max_matching[1][0], max_matching[1][1]) << endl;
	return 0;
}
