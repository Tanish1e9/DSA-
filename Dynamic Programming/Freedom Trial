LC link: https://leetcode.com/problems/freedom-trail/


// Normal  DP approach
// TC O(n*m*n) 
int dp[100][100];
int helper(int i, int j, string &ring, string &key) {
    int n = ring.size();
    if(j==key.size()) return 0;
    if(dp[i][j]!=-1) return dp[i][j];

    int ans = 1e9;
    int k = i;
    do{
        if(ring[k] == key[j]) {
            ans = min(ans, min((k-i+n)%n, (i-k+n)%n) + helper(k,j+1,ring,key));
        }
        k = (k+1)%n;
    } while(k!=i);
    
    return dp[i][j] = ans;
}
int findRotateSteps(string ring, string key) {
    memset(dp, -1, sizeof(dp));
    return helper(0,0,ring, key) + key.size();
}




// Graph ke angle pe socha, ye optimal h
// Dijkstra lagao
// TC is O(nmlog(n))

int findRotateSteps(string ring, string key) {
    vector<vector<int>> pos(26);
    int n = ring.size();
    for(int i=0;i<n;i++) { 
        char c = ring[i];
        pos[c-'a'].push_back(i);
    }

    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
    pq.push({0,0,0});
    vector<vector<int>> distance(n, vector<int> (key.size()+1, 1e9));
    distance[0][0] = 0;
    while(!pq.empty()) {
        auto curr = pq.top();
        pq.pop();
        int dist = curr[0];
        int keyIndex = curr[1];
        int ringIndex = curr[2];
        if(keyIndex == key.size()) return dist+key.size();
        if(dist > distance[ringIndex][keyIndex]) continue;
        for(int i:pos[key[keyIndex]-'a']) {
            int d = min((i-ringIndex+n)%n, (ringIndex-i+n)%n);
            if(dist+d < distance[i][keyIndex+1]){
                distance[i][keyIndex+1] = dist+d;
                pq.push({dist+d, keyIndex+1, i});
            }
        }
    }
    // dummy return
    return -1;
}
