LC link: https://leetcode.com/problems/count-the-number-of-inversions/

    // isme ind bas move krta rhega taaki limit me rhe saare inversions
    // aur wahi thought h ki i numbers place kr chuke h agla number place krenge to usse kitna 
    // aur inversions create kr skte to bas create krte jayenge
    // aur end me return 1 hota jayega because hmesha sahi hi rhega inversions
    // because inv+j==limit pehle hi check kr rakhe h na

    const int mod=1e9+7;
    int dp[301][401];
    int f(int i,int inv,int n,auto&requirements,int ind){
        if(i==n) return 1;
        if(dp[i][inv]!=-1) return dp[i][inv];
        bool flag=false;
        if(requirements[ind][0]==i) flag=true;
        int limit = requirements[ind][1];
        int ans=0;
        for(int j=0;j<=i;j++){
            if(!flag && inv+j<=limit)
            ans=(ans+f(i+1,inv+j,n,requirements,ind))%mod;
            else if(flag && inv+j==limit)
            ans=(ans+f(i+1,inv+j,n,requirements,ind+1))%mod;
        }
        return dp[i][inv]=ans;
    }
    int numberOfPermutations(int n, vector<vector<int>>& requirements) {
        sort(requirements.begin(),requirements.end());
        memset(dp,-1,sizeof(dp));
        return f(0,0,n,requirements,0);
    }


// Ulta DP hai ye
// yaha if(i==1) return inv==0 kyu nahi kie? kyunki 1 number se bhi to sirf 0 hi inversions bante?
// islie ki ho skta h req faltu si de de ki 1 number se aapko 1 banana h usme 0 return krna h na
// agar inv maan lete h 0 aa gya to 0 return hona chahye since requirement satisfied nahi h
// islie i==0 pe kie jab saara requirement poora ho chuka hoga
// fir tabulate kr die h dekho, aur prefix_sum laga die waise hi bhut fast ho chuka h

    const int mod = 1e9+7;
    int memo[301][401];
    int helper(int i, int j, int inv, auto &req) {
        if(i==0) return inv==0;
        if(memo[i][inv]!=-1) return memo[i][inv];
        bool flag = false;
        if(j>=0 && i == req[j][0] + 1) {
            if(inv != req[j][1]) return 0;
            flag = true;
        }
        int limit = min(i-1, inv);
        int ans = 0;
        for(int k=0;k<=limit;k++) {
            ans = (ans + helper(i-1, j-flag, inv-k, req))%mod;
        }
        return memo[i][inv] = ans;
    }
    int numberOfPermutations(int n, vector<vector<int>>& req) {
        sort(req.begin(), req.end());
        // memset(memo, -1, sizeof(memo));
        // return helper(n, req.size() - 1, req.back()[1], req);

        memset(memo, 0, sizeof(memo));
        int pre_sum[401];
        memo[0][0] = 1;
        int j=0;
        for(int i=1;i<=n;i++) {
            pre_sum[0] = memo[i-1][0];
            for(int j=1;j<=400;j++) {
                pre_sum[j] = (pre_sum[j-1] + memo[i-1][j])%mod;
            }
            if(i==req[j][0]+1) {
                int inv = req[j][1];
                int limit = min(i-1, inv);
                memo[i][inv] = pre_sum[inv];
                if(inv-limit>=1) memo[i][inv] = (memo[i][inv] + mod - pre_sum[inv-limit-1])%mod;
                j++;
            } else {
                for(int inv=req[j][1];inv>=0;inv--) {
                    int limit = min(i-1, inv);
                    memo[i][inv] = pre_sum[inv];
                    if(inv-limit>=1) memo[i][inv] = (memo[i][inv] + mod - pre_sum[inv-limit-1])%mod;
                }
            }
        }
        return memo[n][req.back()[1]];
    }


// Space optimised
const int mod = 1e9+7;
int numberOfPermutations(int n, vector<vector<int>>& req) {
    sort(req.begin(), req.end());

    vector<int> prev(req.back()[1]+1, 0);
    vector<int> pre_sum(req.back()[1]+1, 0);
    prev[0] = 1;
    int j=0;
    for(int i=1;i<=n;i++) {
        pre_sum[0] = prev[0];
        for(int j=1;j<=req.back()[1];j++) {
            pre_sum[j] = (pre_sum[j-1] + prev[j])%mod;
        }
        if(i==req[j][0]+1) {
            int inv = req[j][1];
            int limit = min(i-1, inv);
            prev.assign(req.back()[1]+1, 0);

            prev[inv] = pre_sum[inv];
            if(inv-limit>=1) prev[inv] = (prev[inv] + mod - pre_sum[inv-limit-1])%mod;
            j++;
        } else {
            for(int inv=req[j][1];inv>=0;inv--) {
                int limit = min(i-1, inv);
                prev[inv] = pre_sum[inv];
                if(inv-limit>=1) prev[inv] = (prev[inv] + mod - pre_sum[inv-limit-1])%mod;
            }
        }
    }
    return prev[req.back()[1]];
}
