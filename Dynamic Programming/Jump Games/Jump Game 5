LC link: https://leetcode.com/problems/jump-game-v/description/

// Dekh isme na prevGreater and nextGreater using monotonic stacks nikalke
// effective limits nikalwa lo
// aur fir increasing order of heights me process kro 
// segment tree se range maxima aa hi jayega aur bas ho gya
// Par yaha constraint chota h to easily kr dia
// yahi bada hota to mountain range jaisa ekdum kr dete

int dp[1000];
int helper(int i, auto &arr, int d) {
    int n = arr.size();
    if(dp[i]!=-1) return dp[i];

    int ans = 1;
    int r = min(i+d, n-1);
    for(int j=i+1;j<=r;j++) {
        if(arr[i] <= arr[j]) break;
        ans = max(ans, 1+helper(j, arr, d));
    }
    int l = max(i-d, 0);
    for(int j=i-1;j>=l;j--) {
        if(arr[i] <= arr[j]) break;
        ans = max(ans, 1+helper(j, arr, d));
    }
    return dp[i] = ans;
}
int maxJumps(vector<int>& arr, int d) {
    memset(dp, -1, sizeof(dp));
    int ans = 0, n = arr.size();
    for(int i=0;i<n;i++) {
        ans = max(ans, helper(i,arr,d));
    }
    return ans;
}



// M-2
class seg_tree{
    #define L (ind<<1) + 1
    #define R (ind<<1) + 2
    public:
    vector<int> seg;
    seg_tree(int n) {
        seg.assign(4*n, 0);
    }
    void point_update(int ind, int low, int high, int k, int val) {
        if(k<low || high<k) return;
        if(low==high && low==k) {
            seg[ind] = val;
            return;
        }
        int mid = low + (high-low)/2;
        point_update(L, low, mid, k, val);
        point_update(R, mid+1, high, k, val);
        seg[ind] = max(seg[L], seg[R]);
    }
    int query(int ind, int low, int high, int l, int r) {
        if(r<low || high<l) return 0;
        if(l<=low && high<=r) return seg[ind];
        int mid = low + (high-low)/2;
        int left = query(L, low, mid, l, r);
        int right = query(R, mid+1, high, l, r);
        return max(left, right);
    }
    #undef L
    #undef R
};
int maxJumps(vector<int>& arr, int d) {
    int n = arr.size();
    vector<int> prevGreater(n, -1), nextGreater(n, n);
    stack<int> st;
    for(int i=0;i<n;i++) {
        while(!st.empty() && arr[st.top()] < arr[i]) {
            int curr = st.top();
            st.pop();
            nextGreater[curr] = i;
            if(!st.empty()) prevGreater[curr] = st.top();
        }
        st.push(i);
    }
    while(!st.empty()) {
        int curr = st.top();
        st.pop();
        nextGreater[curr] = n;
        if(!st.empty()) prevGreater[curr] = st.top();
    }

    vector<pair<int,int>> nums(n);
    for(int i=0;i<n;i++) {
        nums[i].first = arr[i];
        nums[i].second = i;
    }
    sort(nums.begin(), nums.end());
    seg_tree stree(n);
    int ans = 0;
    for(int i=0;i<n;i++) {
        int idx = nums[i].second;
        int l = max({idx-d, prevGreater[idx]+1, 0});
        int r = min({idx+d, nextGreater[idx]-1, n-1});
        int val = 1 + stree.query(0,0,n-1,l,r);
        ans = max(ans, val);
        stree.point_update(0,0,n-1,idx,val);
    }
    return ans;
}
