GFG link: https://www.geeksforgeeks.org/problems/printing-longest-increasing-subsequence/1

    // yaha lis_ending[i] denotes LIS length ending at arr[i]
    // aur fir to backtrack kr rhe samajh aa hi rha h
    // lexicographically smallest index waala LIS chahye islie dekho jitna shuru ka element le sake wo lia gya h har jagah
    // dekho prev ko 0 se aage iterate kra rhe
    // to islie lexicographically smallest aa hi jayega because jo first prev satisfy kra dega wo hi ayega (since > hai >= nahi)

    vector<int> getLIS(vector<int>& nums) {
    	int n = nums.size();
    	vector<int> lis_ending(n, 1);
    	vector<int> parent(n, -1);
    	int max_val = 0;
    	int last_ind = -1;
    	for(int i=0;i<n;i++) {
    	    for(int prev = 0;prev < i;prev++) {
    	        if(nums[prev] < nums[i] && lis_ending[prev] + 1 > lis_ending[i]) {
    	            lis_ending[i] = lis_ending[prev] + 1;
    	            parent[i] = prev;
    	        }
    	    }
            // ye yaha par hi likhna wrna agar i=0 hua to andar jayega hi nahi
            if(lis_ending[i] > max_val) {
                max_val = lis_ending[i];
                last_ind = i;
            }
    	}
    	vector<int> ans;
    	while(parent[last_ind]!=-1) {
    	    ans.push_back(nums[last_ind]);
    	    last_ind = parent[last_ind];
    	}   
        ans.push_back(nums[last_ind]);
        reverse(ans.begin(), ans.end());
    	return ans;
    }

// Ye rha O(nlogn) me printing
// basically ek inserted_at_length har ek element k lie rakh lo fir increasing length k order me print kr skte wo ek LIS hoga
// index wise lexicographically smallest k lie thoda mehnat kie h like map bana lie aur fir end se chalte ja rhe h
// ab jab bhi element daal sake that is uska next index allow kre to daal dena h because we are choosing lower index elements
// aur ye jo lower bound waale ka intuition h na ye yahi h ki at a given length sabse minimum se minimum value rakha jaye taaki there is more room for expansion
// aur ye yaad rakhna ki arr is not the LIS rather it is the smallest values for every possible length yaani there will be some inc subsequence
// of the length ending with that value which is in arr
// Aur ek baat ki nums me repitition ho skta h na values ka to map agar banake usme nums[i] ko key rakh ke idx + 1 store krte 
// to galat ho skta h islie i ko hi key rakhke store krna h ab jab aisa h hi to vector bana die

    vector<int> getLIS(vector<int>& nums) {
        vector<int> arr;
        vector<int> inserted_at(nums.size());
        for(int i=0;i<nums.size();i++) {
            int idx = lower_bound(arr.begin(), arr.end(), nums[i]) - arr.begin();
            if(idx == arr.size()) arr.push_back(nums[i]);
            else arr[idx] = nums[i];
            inserted_at[i] = idx + 1;
        }
        vector<int> seq(arr.size(), -1);
        for(int i=nums.size()-1;i>=0;i--) {
            if(inserted_at[i] == arr.size() || seq[inserted_at[i]] > nums[i]) {
                seq[inserted_at[i] - 1] = nums[i];
            }
        }
        
        return seq;
    }
