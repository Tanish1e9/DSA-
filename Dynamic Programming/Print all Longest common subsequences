GFG link: https://www.geeksforgeeks.org/problems/print-all-lcs-sequences3413/1

	// ye niche wala intuition right to left jaa rhe aisa DP maanke likha gya h
	// but code niche wala left to right maanke likh rhe waisa h
	// but padh ke samajh aa jayega

	// dekh isme na pehle approach dimag me aata h ki jaise any one LCS print kr rhe the na usi me
	// we will check ki left and up wale agar equal ho memo me to dono paths ko traverse kre through recursion
	// aur jab s[i-1]=t[j-1] ho tab to ye equal character aayega hi end me
	// par usse bhut repetitions banenge aur ye question me TLE de rha tha I tried to use a set<string>
	// so krna ye h ki we will try to construct LCS letter by letter from the end 
	// why end because hmlog memo[i][j] ko s[0...i-1],t[0....j-1] maane hue h
	// so we will pick a character and find its rightmost position in both strings
	// then jo bhi position mila suppose x and y so check memo[x+1][y+1] + temp.size() == lcs_len
	// yaani ye character ko ye position pe leke can we form a LCS 
	// if Yes then we are done for that character and just call the recurrence
	// for eg dekh abc, abac me b ko dhundega to ab,ab substrings me max len to 2 milega which is not lcs ... to b ko
	// leke aage jaake skip krne se behtar h call hi na kre that's why we check 

	// Why does this work and jo pehle soch rhe the memo[i+1][j] and memo[i][j+1] dono pe chale jayenge doesnt?
	// because there can be many starting points with the same character and the same LCS length
	// to bhut redundancies hai
	// but agar character fix krke leftmost se aage badhe
	// then we are going character by character ... to ho skta h bhut sare starting points ho uss character ke but hmlog
	// leftmost pakad ke aage badhte because that doesn't hurt anyone

    void create_memo(string &str1, string &str2, auto &memo) {
        int n = str1.size();
        int m = str2.size();
        
        for(int i=n-1;i>=0;i--) {
            for(int j=m-1;j>=0;j--) {
                if(str1[i] == str2[j]) memo[i][j] = 1 + memo[i+1][j+1];
                else memo[i][j] = max(memo[i+1][j], memo[i][j+1]);
            }
        }
    }
    
    void helper(int i, int j, string &str1, string &str2, string &temp, auto &ans, auto &memo) {
        if(temp.size() == memo[0][0]) {
            ans.push_back(temp);
            return;
        }
        for(char c='a';c<='z';c++) {
            int l1=i, l2=j;
            for(;l1<str1.size();l1++) {
                if(str1[l1] == c) break;
            }
            for(;l2<str2.size();l2++) {
                if(str2[l2] == c) break;
            }
            if(l1 < str1.size() && l2<str2.size() && memo[l1][l2] + temp.size() == memo[0][0]) {
                temp.push_back(c);
                helper(l1+1, l2+1, str1, str2, temp, ans, memo);
                temp.pop_back();
            }
        }
    }
    
    vector<string> allLCS(string &str1, string &str2) {
        int n = str1.size();
        int m = str2.size();
        vector<vector<int>> memo(n+1, vector<int>(m+1,0));
        create_memo(str1, str2, memo);
        if(memo[0][0] == 0) return {};
        string temp;
        vector<string> ans;
        helper(0,0,str1,str2,temp,ans,memo);
        sort(ans.begin(), ans.end());
        return ans;
    }
