LC link: https://leetcode.com/problems/remove-boxes/

// Iss testcase par tumhara intuitive solution galat hoga
// [2,1,1,2,1,1,2,2]
// intuition ki koi ek colour pick krenge and baki saare colours ko hatake, jo picked colour h
// uske boxes ko last me hatayenge milake
// ye galat h halanki ye to sahi h ki jitna ho sake ek substring jo choose krenge usko expand krenge left, right me

// Ye rha O(n^4) code
// Correct intuition aisa h na ki
// dp[l][r][k] denotes ki arr[r] ke barabar r+1 se n-1 tak, 'k' tho arr[r] aur latka hua h
// ab socho ya to last element ko uske aage jitne h unke sath delete kr denge
// ya fir kisi me merge krke chain ko aur lamba krenge
// bas yahi 2 possibilities pe khela gya h
int dp[100][100][100];
int helper(int l, int r, int k, auto &arr) {
    if(l>r) return 0;
    if(dp[l][r][k]!=-1) return dp[l][r][k];
    while(l<r && arr[r-1]==arr[r]) {
        k++;
        r--;
    }
    int ans = helper(l, r-1, 0, arr) + (k+1)*(k+1);
    for(int i=l;i<r;i++) {
        if(arr[i]==arr[r])
        ans = max(ans, helper(l, i, k+1, arr) + helper(i+1, r-1, 0, arr));
    }
    return dp[l][r][k] = ans;
}
int removeBoxes(vector<int>& boxes) {
    memset(dp, -1, sizeof(dp));
    int n = boxes.size();
    return helper(0,n-1,0,boxes);
}

// Ab isme ye to pata h na ki ek colour ke group ko to ek hi sath krenge process to islie
// next la die isse kya h thoda fast ho jata na jumping
int dp[100][100][100];
int next[100];
int helper(int l, int r, int k, auto &arr) {
    if(l>r) return 0;
    if(dp[l][r][k]!=-1) return dp[l][r][k];
    while(l<r && arr[r-1]==arr[r]) {
        k++;
        r--;
    }
    int ans = helper(l, r-1, 0, arr) + (k+1)*(k+1);
    for(int i=l;i<r;i++) {
        if(arr[i]==arr[r])
            ans = max(ans, helper(l, i, next[i]-i+k, arr) + helper(next[i], r-1, 0, arr));
        i=next[i]-1;
    }
    return dp[l][r][k] = ans;
}
int removeBoxes(vector<int>& arr) {
    memset(dp, -1, sizeof(dp));
    int n = arr.size();
    for(int i=n-1;i>=0;i--) {
        if(i+1<n && arr[i]==arr[i+1]) next[i] = next[i+1];
        else next[i]=i+1;
    }

    return helper(0,n-1,0,arr);
}


// Concise bhi kr skte h thoda
// Actually ye faster bhi hoga kyunki while loop faltu me slow krta recursive call me to dp me
// store ho jayega islie faster hoga
int dp[100][100][100];
int next[100];
int helper(int l, int r, int k, auto &arr) {
    if(l>r) return 0;
    if(dp[l][r][k]!=-1) return dp[l][r][k];
    int ans = helper(l, r-1, 0, arr) + (k+1)*(k+1);
    for(int i=l;i<r;i++) {
        if(arr[i]==arr[r])
            // bas yaha dhyan rakhna hoga na agar arr[r-1] hi arr[r] ke barabar h
            // to r pe cap laga de wrna aage chala jayega next and faltu me bada ans de dega
            ans = max(ans, helper(l, i, min(next[i],r)-i+k, arr) + helper(next[i], r-1, 0, arr));
        i=next[i]-1;
    }
    return dp[l][r][k] = ans;
}
int removeBoxes(vector<int>& arr) {
    memset(dp, -1, sizeof(dp));
    int n = arr.size();
    for(int i=n-1;i>=0;i--) {
        if(i+1<n && arr[i]==arr[i+1]) next[i] = next[i+1];
        else next[i]=i+1;
    }

    return helper(0,n-1,0,arr);
}
