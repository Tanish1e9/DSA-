LC link: https://leetcode.com/problems/russian-doll-envelopes/description/


// Ye best code h aur it is developed from the general 2D LIS code only
// Dekh yaha nums ko sort krke general LIS ka code laga doge to bhi accept ho jayega
// But yaha hmlog kuch aur observations se thoda kaam aasan kr skte h
// (READ 2D LIS FIRST) 
// to jo buckets hote h unme hmlog ko check krne k lie simply lower bound - 1 pe check krna 
// hota but since yaha pe x increasing h to sirf end waale 2 elements dekh ke kaam ho skta
// Ab ye 2 elements bhi islie dekhne pad rhe ki agar x same ho gya bucket ke aakhri waale ka
// to uske pichla wala chahye hoga
// par ye dikkat tabhi aa rhi h jab x same ho kyunki agar x bina check kie kr dia
// to same x waale hi ek dusre ko extend kr denge jo ki galat hoga
// to islie socho ki x same hone par y pe decreasing sort kr dete h
// to same x waala koi extend ho hi nahi payega
// y pe to check kr hi rhe islie y same hone par koi dikkat nhi h
// To iss tarah se ek hi element pe kaam ho jayega and x pe check krne ka jroorat nahi 
// to bas y coordinates store krenge bucket ke aakhri element ka and we will be done

int maxEnvelopes(vector<vector<int>>& nums) {
    int n = nums.size();
    // nums ko ek vector<pair<int,int>> bna doge to fast ho jayega
    // faltu h islie nahi kia
    vector<int> arr;
    sort(nums.begin(), nums.end(), [](vector<int> &a, vector<int> &b){
        if(a[0]!=b[0]) return a[0] < b[0];
        return a[1] > b[1];
    });
    for(int i=0;i<n;i++) {
        int idx = lower_bound(arr.begin(), arr.end(), nums[i][1]) - arr.begin();
        if(idx == arr.size()) arr.push_back(nums[i][1]);
        else arr[idx] = nums[i][1];
    }
    return arr.size();
}








// Ye segment_tree ka solution h
// Ye general 2D LIS problem nahi solve kr skta since here
// hmlog increasing x consider kr rhe h
// However 1D LIS segment tree se kr skte h but overkill h
// Not the most optimal, but accept ho jayega
// 2 major things in this :- 
// 1) observe ki agar x coordinate same ho to y ko 
// decreasing order me sort kia gya h... why?
// taaki same x me bade y wale kahi chote y walo ko hi extend na 
// kr de
// 2) Same y coordinate ka jagah same h... kyunki maan lo ki koi first point aaya 
// jiska y coordinate kisi pehle wale point k y coordinate ke equal h
// to ab aage ka socho ki x coordinate same rhte rhte y chota ya equal hi hoga... to unko to current y 
// se fark ni padega... aur aage x coordinate bada ho jayega to agar unko iss y se fark pade
// to current wala point ka hi y store krna chahye... because current point ka LIS length piche wale
// same y wale point se >= hi hoga
                                          

class seg_tree{
    #define L (ind<<1) + 1
    #define R (ind<<1) + 2
    public:
    vector<int> seg;
    seg_tree(int n) {
        seg.assign(4*n, 0);
    }
    void point_update(int ind, int low, int high, int k, int val) {
        if(k<low || high<k) return;
        if(low==high && low==k) {
            seg[ind] = val;
            return;
        }
        int mid = low + (high-low)/2;
        point_update(L, low, mid, k, val);
        point_update(R, mid+1, high, k, val);
        seg[ind] = max(seg[L], seg[R]);
    }
    int query(int ind, int low, int high, int l, int r) {
        if(r<low || high<l) return 0;
        if(l<=low && high<=r) return seg[ind];
        int mid = low + (high-low)/2;
        int left = query(L, low, mid, l, r);
        int right = query(R, mid+1, high, l, r);
        return max(left, right);
    }
    #undef L
    #undef R
};
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& arr) {
        int n = arr.size();
        for(int i=0;i<n;i++) arr[i].push_back(i);
        
        sort(arr.begin(), arr.end(), [](vector<int> &a, vector<int> &b) {
            return a[1] < b[1];
        });

        vector<int> jagah(n);
        for(int i=0;i<n;i++) {
            jagah[arr[i][2]] = i;
            int j = i;
            while(i+1<n && arr[i+1][1] == arr[i][1]) {
                jagah[arr[i+1][2]] = j;
                i++;
            }
        }

        sort(arr.begin(), arr.end(), [](vector<int>&a, vector<int> &b){
            if(a[0]!=b[0]) return a[0] < b[0];
            return a[1] > b[1];
        });

        int ans = 1;
        seg_tree stree(n);
        for(int i=0;i<n;i++) {
            int val = stree.query(0,0,n-1,0,jagah[arr[i][2]]-1);
            ans = max(ans, val+1);
            stree.point_update(0,0,n-1,jagah[arr[i][2]],val+1);
        }
        
        return ans;
    }
};

