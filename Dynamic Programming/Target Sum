LC link: https://leetcode.com/problems/target-sum/description/

    // dekh target is the subset sum I am requiring here
    // so if target turns out negative and the array has only positive numbers it should be 0
    int helper(vector<int>&arr,int sum){
        int n=arr.size();
        vector<int>prev(sum+1,0);
        vector<int>curr(sum+1,0);
        for(int i=0;i<n;i++){
            for(int k=0;k<=sum;k++){
                if(i==0){
                    if(k==0) curr[k]=(arr[0]==0)+1;
                    else curr[k] = (arr[0]==k);
                }
                else{
                    int pick=0;
                    if(k>=arr[i]) pick=prev[k-arr[i]];
                    int npick = prev[k];
                    curr[k]= pick+npick;
                }
            }
            prev=curr;
        }
        return prev[sum];
    }
    int findTargetSumWays(vector<int>& nums, int d) {
        int tot = accumulate(nums.begin(),nums.end(),0);
        int target=(tot+d);
        if(target < 0) return 0;
        if(target&1) return 0;
        return helper(nums,target/2);
    }



// Agar koi indices maang le to aise krna h
// simple hi h mtlb isi dp array se we can derive the subset also, actual subset store mat krne lag jana
Link : https://maang.in/problems/Subset-Sum-Queries-760?resourceUrl=cs70-cp476-pl3255-rs760&returnUrl=%5B%22%2Fcourses%2FDP-Workshop-Vivek-Gupta-Youtube-70%3Ftab%3Dchapters%22%5D

int dp[100][100001];
vector<vector<int>> subset_queries(vector<int> &arr, vector<int> &queries) {
    // Write code here.
    int n = arr.size();
    memset(dp, 0, sizeof(dp));

    dp[0][arr[0]] = 1;
    for(int i=0;i<100;i++) dp[i][0] = 1;

    for(int i=1;i<n;i++) {
        for(int j=1;j<=1e5;j++) {
            if(j>=arr[i]) dp[i][j] = dp[i-1][j-arr[i]];
            dp[i][j] = dp[i][j] | dp[i-1][j];
        }
    }

    vector<vector<int>> ans;
    for(int i:queries) {
        if(dp[n-1][i]==0) ans.push_back({-1});
        else {
            ans.push_back(vector<int>());
            int sum = i;
            for(int j=n-1;j>=0;j--) {
                if(sum == 0) break;
                if(j>=1 && sum >= arr[j] && dp[j-1][sum-arr[j]]) {
                    ans.back().push_back(j);
                    sum -= arr[j];
                }
            }
            if(sum>0) ans.back().push_back(0);
            // The question required sorted order that's why
			reverse(ans.back().begin(), ans.back().end());
        }
    }

    return ans;
}
