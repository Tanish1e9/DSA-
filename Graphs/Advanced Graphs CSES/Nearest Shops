CSES link: https://cses.fi/problemset/task/3303/

#include<bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n, m, k;
	cin >> n >> m >> k;
	vector<vector<int>> adj(n+1);
	queue<pair<int,int>> q;
	
	vector<int> dist(n+1, 1e18);
	vector<int> who(n+1, -1);
	for(int i=0;i<k;i++) {
		int x;
		cin >> x;
		q.push({x,x});
	}
	for(int i=0;i<m;i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	
	int level = 0;
	while(!q.empty()) {
		level++;
		int level_size = q.size();
		while(level_size--) {
			auto curr =  q.front();
			q.pop();
			for(int el:adj[curr.first]) {
				// Ye to simple maan lo 1 se shuruwat hua 2 pe gya
				// then 2 jab 1 ko dekhega to cycle complete ho gya na
				if(el == curr.second) continue;
				if(dist[el] > level) {
					// yaha who[el] == -1 likhne par galat ho jata
					// ye baat sach h ki koi node pehli bar visit hoga to hi minimum distance usme likha jayega
					// but who[el] == -1 se kyu galat hota?
					// take 4-1-2-3 where 1,3,4 are shops
					// ab maan le pehle 1 jo h wo 2, 4 ko visit kr dia
					// then 3 2 ko visit kia aur dekha ki 1,3 sahi rhega
					// to 1 ka bhi who wo 3 set kr dia with distance 2
					// ab 4 1 ke paas gya to dekha ki pehle se uska who set h to skip kr gya
					// jabki 4 minimum distance dene waala tha
					dist[el] = level;
					who[el] = curr.second;
					q.push({el, curr.second});
					// ye who[el]!=curr.second likhna jroori h
					// 1<->2, 2<->3, 3<->1 dekh lo with 1 as shop... to dikhega ki 2 jab 3 ko dekhega 
					// to same hi owners honge
				} else if(who[el] != curr.second) {
					// distance already set h el ka with some other shop 

					// take eg 1-2-3-4-5-6-7 with 1,2,7 as shops
					// to 1,2 ka to distance 1 set ho gya hoga
					// but fir 4 pe clash hoga to 7 ke lie distance update krna h
					// but 2 ke lie nahi, islie dono ke lie independent checks lagaye h
					if(dist[curr.second] > level + dist[el]) {
						dist[curr.second] = level + dist[el];
						who[curr.second] = who[el];
					}
					if(dist[who[el]] > level + dist[el]) {
						dist[who[el]] = level + dist[el];
						who[who[el]] = curr.second;
					}
				}
			}
		}
	}


	for(int i=1;i<=n;i++) {
		if(dist[i]!=1e18) cout << dist[i] << " ";
		else cout << -1 << " ";
	}
	cout << endl;

	return 0;
}
