CSES link: https://cses.fi/problemset/task/1197/

// dfs nahi kr skte because aise cases banaye ja skte h
// ki bich me kahi positive cycle me ghuske valid negative cycle bhi na detect kr paye
// also we cant say ki bellman me nth iteration me jo do nodes involved h usme se koi bhi
// kisi negative cycle ka part ho hi
// Here we dont have any starting point hence 1e18 wala check mat lagana
// islie yaha sirf bellman me hi parent mark krte jao obviously cycle bhi aa hi gya hoga then start with any node
// whose parent is != -1
// and then path reverse krke wapas trim down hoga

#include<bits/stdc++.h>
using namespace std;
#define int long long
void bellman(int n, int m, auto &edges) {
	vector<int>distances(n+1,0);
	vector<int>parent(n+1,-1);
	for(int i=0;i<n-1;i++) {
		for(int j=0;j<m;j++) {
			int a = edges[j][0];
			int b = edges[j][1];
			int c = edges[j][2];
			if(distances[b] > distances[a] + c) {
				distances[b] = distances[a] + c;
				parent[b]=a;
			}
		}
	}
	int start = -1;
	for(int j=0;j<m;j++) {
		int a = edges[j][0];
		int b = edges[j][1];
		int c = edges[j][2];
		if(distances[b] > distances[a] + c) {
			distances[b] = distances[a] + c;
			parent[b]=a;
			start=b;
			break;
		}
	}
	if(start == -1){
		cout << "NO\n";
		return;
	} else {
		vector<bool>vis(n+1, false);
		vector<int>path;
		
		while(!vis[start]) {
			path.push_back(start);
			vis[start] = true;
			start = parent[start];
		}
		path.push_back(start);
		reverse(path.begin(), path.end());
		cout << "YES\n";
		for(int i=0;i<path.size();i++) {
			cout << path[i] << " ";
			if(i>0 && path[i]==path[0]) break;
		}
		cout << endl;
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, m;
	cin >> n >> m;
	vector<vector<int>> edges;
	for(int j=0;j<m;j++) {
		int a,b,c;
		cin >> a >> b >> c;
		edges.push_back({a,b,c});
	}
	bellman(n,m,edges);
	return 0;
}
