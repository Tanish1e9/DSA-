CSES link: https://cses.fi/problemset/task/1160/

// Dekh isme na pehle to ye realize krna tha ki kahi se bhi start kro ultimately ek cycle me aake fasoge hi
// to ek tarah se aisa imagine krlo ki ek golchakkar h usme ghusne k bhut raaste h
// aur iss pure ko ek componenet ki tarah treat kro. There can be multiple components.
// Components simply direction ko ignore krke we can find through DSU.
// Baki ek component k andar analysis kro ki ek node se dusra node kab reachable hoga. 
// Cycle se distance agar calculate krle so that can help.
// Usi ke lie fir niche line 100 wala for loop h

#include<bits/stdc++.h>
using namespace std;
#define int long long
class DSU{
	public:
	vector<int> size, parent;
	DSU(int n) {
		size = vector<int>(n+1, 0);
		parent = vector<int>(n+1, -1);
		for(int i=0;i<=n;i++) parent[i]=i;
	}
	void add(int a, int b) {
		int ult_a = find_par(a);
		int ult_b = find_par(b);
		if(ult_a == ult_b) return;
		if(size[ult_a] > size[ult_b]) {
			parent[ult_b] = ult_a;
			size[ult_a] += size[ult_b];
		}
		else {
			parent[ult_a] = ult_b;
			size[ult_b] += size[ult_a];
		}
	}
	int find_par(int node) {
		if(parent[node]==node) return node;
		return parent[node] = find_par(parent[node]);
	}
};
void populate(int n, auto &next){
	int k=1;
	while((1<<k) <= n) {
		for(int i=1;i<=n;i++) {
			int mid = next[k-1][i];
			next[k][i] = next[k-1][mid];
		}
		k++;
	}
}
pair<int,int> find_dist(int node, auto &next, auto &cycle_size) {
	if(cycle_size[node]!=-1) return {0, node};	// in the cycle only
	int dist = 1;
	for(int i=17;i>=0;i--) {
		int p = next[i][node];
		if(p!=-1 && cycle_size[p]==-1) {
			dist += (1<<i);
			node = p;
		}
	}
	// sath me nearest cycle wala node bhi return krte
	return {dist, next[0][node]};
}
int solve(int a, int b, auto &ds, auto &next, auto &level, auto &cycle_size)  {
	if(ds.find_par(a)!=ds.find_par(b)) return -1;
	auto a_info = find_dist(a, next, cycle_size);
	auto b_info = find_dist(b, next, cycle_size);
	int dist_a = a_info.first;
	int dist_b = b_info.first;
	if(dist_b > dist_a) return -1;
	if(cycle_size[b]!=-1) {
		// b is in the cycle
		return dist_a + (level[b] - level[a_info.second] + cycle_size[b])%cycle_size[b];
	} 
	// a and b both not in cycle
	// kyunki agar a cycle me hota to uska distance 0 hota but b ka to kuch > 0 hoga 
	// hence pehle hi -1 return ho chuka hota
	int diff = dist_a - dist_b;
	for(int i=17;i>=0;i--) {
		if((1<<i) & diff) a = next[i][a];
	}
	if(a==b) return diff;
	return -1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, q;
	cin >> n >> q;
	vector<vector<int>> next(18, vector<int>(n+1, -1));
	DSU ds(n+1);
	for(int i=1;i<=n;i++) {
		cin >> next[0][i];
		ds.add(i,next[0][i]);
	}
	populate(n, next);
	vector<int> vis(n+1, -1);
	vector<int> level(n+1, -1);
	vector<int> cycle_size(n+1, -1);
	for(int i=1;i<=n;i++) {
		if(vis[i]!=-1) continue;
		int start = i;
		int l = 0;
		vector<bool>path_vis(n+1, false);
		while(vis[start]==-1) {
			vis[start] = l++;
			path_vis[start] = true;
			start = next[0][start];
		}
		// path_vis islie ki pata kr ske ki wo jo node already visited aaya h wo same path me h 
		// agar to cycle banana hoga
		// Also, vis[i] me levels store krna pada to find out cycle size just in case
		// and fir wapas se chalke we populated the levels in all the cyclic nodes
		int size = l - vis[start];
    // Ek bar ek cycle discover hoke populate ho chuka h then wo cycle kabhi dubara ni discover ho payega
    // Hence, agar koi cycle discover hota h to we can rest assured ki wo koi naya cycle hi hoga.
		if(!path_vis[start]) continue;
		l=0;
		while(cycle_size[start]==-1) {
			level[start] = l++;
			cycle_size[start] = size;
			start = next[0][start];
		}
	}


	while(q--) {
		int a, b;
		cin >> a >> b;
		cout << solve(a,b,ds,next,level,cycle_size) << "\n";
	}
	return 0;
}
