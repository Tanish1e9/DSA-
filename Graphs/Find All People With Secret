LC link: https://leetcode.com/problems/find-all-people-with-secret/description/

// 2 solutions h ek to Dijkstra like aur ek DSU se
// DSU wala faster than dijkstra h since logarithmic factor nahi h na 
// DSU wala aa gya tha dimag me pehle hi but pata nahi kyu lag rha tha TLE maarega
// Fir krke dekhe to faster h wo


class DSU{
    public:
    vector<int> parent, size;
    DSU (int n) {
        parent.resize(n);
        iota(parent.begin(), parent.end(), 0);
        size.assign(n, 1);
    }
    int find_par(int node) {
        if(parent[node]==node) return node;
        return parent[node] = find_par(parent[node]);
    }
    void union_by_size(int a, int b) {
        int ult_a = find_par(a);
        int ult_b = find_par(b);
        if(ult_a == ult_b) return;
        if(size[ult_a] > size[ult_b]) {
            size[ult_a] += size[ult_b];
            parent[ult_b] = ult_a;
        }
        else {
            size[ult_b] += size[ult_a];
            parent[ult_a] = ult_b;
        }
    }
    void reset(int node) {
        parent[node] = node;
        size[node] = 1;
    }
};
class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        // int m = meetings.size();
        // vector<vector<pair<int,int>>> adj(n);
        // adj[0].push_back({firstPerson, 0});
        // for(int i=0;i<m;i++) {
        //     adj[meetings[i][0]].push_back({meetings[i][1], meetings[i][2]});
        //     adj[meetings[i][1]].push_back({meetings[i][0], meetings[i][2]});
        // }
        // vector<int> know(n, 1e9);
        // know[0] = 0;
        // priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        // pq.push({0,0});
        // while(!pq.empty()) {
        //     auto curr = pq.top();
        //     pq.pop();
        //     int node = curr.second;
        //     int t = curr.first;
        //     if(know[node] < t) continue;
        //     for(auto el:adj[node]) {
        //         if(el.second >= t) {
        //             if(know[el.first] > el.second) {
        //                 know[el.first] = el.second;
        //                 pq.push({el.second, el.first});
        //             }
        //         }
        //     }
        // }
        // vector<int> ans;
        // for(int i=0;i<n;i++) {
        //     if(know[i]!=1e9) ans.push_back(i);
        // }
        // return ans;

        int m = meetings.size();
        sort(meetings.begin(), meetings.end(), [](vector<int>&a, vector<int>&b){
            return a[2] < b[2];
        });
        DSU ds(n);
        ds.union_by_size(0,firstPerson);
        int i=0;
        while(i<m) {
            int j=i;
            ds.union_by_size(meetings[i][0], meetings[i][1]);
            while(i+1<m && meetings[i+1][2] == meetings[i][2]) {
                i++;
                ds.union_by_size(meetings[i][0], meetings[i][1]);
            }

            for(int p=j;p<=i;p++) {
                if(ds.find_par(0)!=ds.find_par(meetings[p][0])) {
                    ds.reset(meetings[p][0]);
                    ds.reset(meetings[p][1]);
                }
            }
            i++;
        }
        vector<int> ans;
        for(int i=0;i<n;i++) {
            if(ds.find_par(i)==ds.find_par(0)) ans.push_back(i);
        }
        return ans;
    }
};


