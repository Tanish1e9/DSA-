- In BFS, queue me node daalte waqt hi usko visited mark kr dena h wrna unnecessarily queue ka size bada hoke TLE dega
- dfs me dfs call krne k pehle mark kro chahe baad me fark ni padta
- if all the edges have weight 1 and we have to find shortest path, we don't need priority queue, queue se hi kaam ho jayega
- Also DAG me shortest path nikalne k lie na Dijkstra nahi chahye normal queue rakhna and traverse the nodes in topological order
- cycle detection in undirected graph
  - vis array and par is required. agar koi already visited node 'p' kisi node 'q' k neighbour me aa jaye and it is not q's parent then cycle is there
  - can be implemented using dfs and bfs easily
- cycle detection in directed graph
  - we need path_vis array but no par is required. think about 1->2->3 and also 1->4->3. If we dont use path_vis, then iss case pe bhi cycle aa jayega which is wrong
  - dfs se kr skte h easily, but bfs me kahn's algo lagega. In kahn's also, we dont require another vis array (since indegree hi kind of kaam kr dega)
- Optimisations in dijkstra
  - Set use kr skte h. Extra line-> agar neighbour me check krte waqt koi kam distance mil gya then original distance, uss node ke pair ko remove kr dena set se
  - In PQ, agar pq se pair pop kie and we get a different distance as compared to the one in distances vector then just skip that node
- Dijsktra for negative weight cycles to infinite loop me jayega
- For negative undirected edges, it's like a cycle only so can't use it
- But directed negative edges me we can use it I believe, but waha na fir ye jo assumption pe chalte h ki minimum distance wala pehle explore kre kind of wohi violate ho rha to bellman ford hi laga lo
- Kabhi bhi directed graph me check krna ho ki ek set of nodes se koi particular node q pahuch skte ya nahi, to reversed_adj list krke q se traversal chala dena and check kr lena ki wo jaha jaha pahucha
- Kabhi maximum distance nikalna pade to saare distances ko negate krke minimum distance nikal lena. Fir yaha agar negative cycle mil gya iska mtlb originally positive cycle tha to arbitrarily large distances nikal skte
- Kabhi path waghera kuch nikalna ho na to hmesha parent array ka use krna h (agar koi ek path nikalna ho to)
- Agar saare possible shortest paths nikalne ho then levels ka use krna hoga ya parents ka and ensure ki move krte waqt ek level upar hi ja rhe
- Minimum Spanning Tree ka concept is only for undirected graphs, whereas euler path, circuit, hamiltonian path, circuit ka concepts dono ke lie h. We will study for undirected only as of now.
- Euler me each edge exactly once ka chalta, hamiltonian me each vertex exactly once chalta
  
- Euler Circuit (undirected) - Existence criteria
  - All nodes have even degree
  - All non-zero degree nodes belong to the same connected component
- Agar aisa ho ki koi undirected graph ko directed banana ho such that it is a single SCC, then Eulerian circuit nikalna original undirected graph me and assign edges 2 - 2 ko pakad ke -> Eulerian Orientation
- Euler Path (undirected) - Existence criteria
  - Either 0 or 2 nodes can have odd degree, else every node should have even degree
  - All non-zero degree nodes belong to the same connected component

- Eulerian Circuit (directed)
  - Strong connectivity: every vertex with nonzero degree is in the same strongly connected component.
  - In-degree = Out-degree for every vertex.

- Eulerian Path (directed)
  - Weak connectivity: when you ignore edge directions, all vertices with nonzero degree are connected.
  - Exactly one vertex has outdegree = indegree + 1 → this is the start.
  - Exactly one vertex has indegree = outdegree + 1 → this is the end.
  - All other vertices satisfy indegree = outdegree.

- Hierholzer's Algo na eulerian path and circuit both in directed and undirected graph ke lie kaam aata h
- Also kisi bhi Euler path ka size m+1 hota h pretty obviously
- Koi bhi edge agar kisi cycle ka part hai to Bridge nahi hoga else hoga
- Articulation point ke jitne bhi neighbours hai, agar wo kisi same cycle ke part hai, to concerned point is not an articulation point
