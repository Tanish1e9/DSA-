CSES link: https://cses.fi/problemset/task/3405/

// Ye solution me thoda array use kr lie aur &= krke
// fir rightmost bit ka index k lie __builtin_ctz waghera use krke enough optimise ho gya ki accept ho jaye
// but ye intended solution nahi h look below

#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> xarr(10000007);
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
 
	int n, k;
	cin >> n >> k;
	int x,a,b,c;
	cin >> x >> a >> b >> c;
	int freq[31] = {0};
	
	int ans = 0;
	int curr = 0;
	for(int i=0;i<n;i++) {
		if(i==0) xarr[i] = x;
		else xarr[i] = (a*xarr[i-1]+b)%c;
 
		int num = xarr[i];
		curr |= num;
		while(num > 0) {
			int bits = __builtin_ctz(num);
			freq[bits]++;
			num &= num-1;
		}
 
		int l = i-k+1;
		if(l>=0) {
			// window exists
			ans ^= curr;
			
			num = xarr[l];
			while(num > 0) {
				int bits = __builtin_ctz(num);
				freq[bits]--;
				if(freq[bits]==0) curr ^= (1ll<<bits);
				num &= num-1;
			}
		}
	}
	cout << ans << "\n";
	return 0;
}


// Isme na k length ke blocks me baant die h (last wale me ho skta <=k ho)
// fir observe krna har ek k length k window ko inhi blocks ke prefix aur suffix se banaya ja skta h
// to bas wahi kie h and ye accepted + intended solution h
// isi ke space ko thoda optimise krenge agle solution me by using only O(k) extra space rather than O(n) here

#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> xarr(10000007), suff(10000007), pref(10000007);
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
 
	int n, k;
	cin >> n >> k;
	int x,a,b,c;
	cin >> x >> a >> b >> c;
	
	int ans = 0;
	int pre = 0;
	int curr_block = 0;
	for(int i=0;i<n;i++) {
		if(i==0) xarr[i] = x;
		else xarr[i] = (a*xarr[i-1]+b)%c;
 
		if(i/k > curr_block) {
			curr_block++;
			pre = 0;
		}
		pre |= xarr[i];
		pref[i] = pre;
	}

	int suf = 0;
	curr_block = (n-1)/k;
	for(int i=n-1;i>=0;i--) {
		if(i/k < curr_block) {
			curr_block--;
			suf = 0;
		}
		suf |= xarr[i];
		suff[i] = suf;
	}

	for(int i=k-1;i<n;i++) {
		int l = i-k+1;
		// l will always be now >=0
		if(i%k==k-1) {
			// if l,i are forming a block itself then taking anyone of pref or suff will suffice
			// Here even if you take both it wont matter since it's bitwise OR but just for clarity
			// I did this
			ans ^= pref[i];
		} else {
			ans ^= pref[i] | suff[l];
		}
	}
	cout << ans << "\n";
	return 0;
}



// Now ye jo h AggStack and AggQueue ka solution ye bhi blocks ka prefix suffix hi maintain kr rha h
// 'in' is maintaining prefix and 'out' is maintaining suffix
// Iss technique me hmlog or k jagah koi bhi aur aggregate function like gcd, min etc laga skte h
// O(k) hi extra space lega at any point of time
// infact isme array bhi store krne ka jroorat nahi h
// sliding window minimum me jo monotonic deque lagaye the wo method har aggregate function me nahi chalega


#include<bits/stdc++.h>
using namespace std;
#define int long long

class AggStack{
	public:
	stack<pair<int,int>> st;
	void push(int x) {
		if(!st.empty()) st.push({x, st.top().second | x});
		else st.push({x,x});
	}
	void pop() {
		st.pop();
	}

	bool empty() {
		return st.empty();
	}

	int query() {
		return st.top().second;
	}

	int top() {
		return st.top().first;
	}
};


class AggQueue{
	public:
	AggStack in, out;
	void push(int x) {
		in.push(x);
	}
	void pop() {
		if(out.empty()) {
			while(!in.empty()) {
				out.push(in.top());
				in.pop();
			}
		}
		out.pop();
	}
	int query() {
		int ans = 0;
		if(!in.empty()) ans |= in.query();
		if(!out.empty()) ans |= out.query();
		return ans;
	}
};
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
 
	int n, k;
	cin >> n >> k;
	int x,a,b,c;
	cin >> x >> a >> b >> c;
	
	int ans = 0, curr = 0;
	AggQueue q;
	for(int i=0;i<n;i++) {
		if(i==0) curr = x;
		else curr = (a*curr+b)%c;
 
		q.push(curr);

		int l = i-k+1;
		if(l>=0) {
			// window exists
			ans ^= q.query();
			q.pop();
		}
	}

	cout << ans << "\n";
	return 0;
}
