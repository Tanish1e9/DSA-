GFG link: https://www.geeksforgeeks.org/problems/search-pattern0205/1
LC link: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/

vector <int> search(string pat, string txt){
    vector<int>ans;
    int m=pat.size();
    int n=txt.size();
    vector<int>hash(m,-1);
    int i=1,j=0;
    while(i<m){
        if(pat[i]==pat[j]){
            hash[i]=j;
            i++;
            j++;
        }
        else{
            if(j>0) j=hash[j-1]+1;
            else i++;
        }
    }
    i=0,j=0;
    while(i<n){
        if(txt[i]==pat[j]){
            i++;
            j++;
            if(j==m){
                ans.push_back(i-m+1);   // +1 for one based indexing
                j=hash[j-1]+1;
            }
        }
        else{
            if(j>0) j=hash[j-1]+1;
            else i++;
        }
    }
    return ans;
}




// One more implementation after 1 year I did, choose whatever you like
// Both have same TC of O(n+m)

vector<int> hashf(string &s) {
    int n = s.size();
    vector<int> ans(n);
    ans[0] = 0;
    int j = 0;
    for(int i=1;i<n;i++) {
        while(j>0 && s[j]!=s[i]) j = ans[j-1];
        if(s[i]==s[j]) {
            ans[i] = j + 1;
            j++;
        } 
        else ans[i] = 0;
    }
    return ans;
}
vector<int> search(string &pat, string &txt) {
    vector<int> h1 = hashf(pat);
    vector<int> ans;
    int j=0;
    for(int i=0;i<txt.size();i++) {
       while(j>0 && pat[j]!=txt[i]) j = h1[j-1];
       
       if(txt[i] == pat[j]) {
           j++;
           if(j == pat.size()) {
               ans.push_back(i+1-pat.size());
               j=h1[j-1];
           }
       }
    }
    
    return ans;
}
