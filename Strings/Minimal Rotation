CSES link: https://cses.fi/problemset/task/1110

// Lyndon's factorisation algorithm to find index of minimal lexicographic rotation
// Ye optimal h dekh simple ekdum h ki i,j do candidates maintain krte chalte h
// achha ss = s+s bana lete taaki modulo waghera na krna pade
// to 2 candidates me se hmesha worse candidate ko eliminate krte chalte
// to dekho i=0, j=1 initialise kr die
// ab jab tk i+k == j+k hai tab tk k++ krte rho
// k is nothing just the first point of difference dekho har bar end pe reset kr hi rhe h
// to first point of difference pe maan lo (i,j) me jo aage h wo wala jiit gya
// to fir i=j+1 kr dena (agar i piche waala tha to)
// kyunki i to j me na har string ko i defeat krke rakha h tabhi i fixed tha aur j itna aage pahuch gya tha
// hmesha haarne waala aage badhta h...
// aur agar piche waala jiit gya to j=j+k+1 kr dena (agar j aage waala ho) 
// kyunki j to j+k ke lie correspondingly i to i+k le lo dekhna i wala hara dega sabko
// bas yahi algo h


#include <bits/stdc++.h>
using namespace std;
int booth(string &s) {
    string ss = s + s;  
    int n = s.size();
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (ss[i + k] == ss[j + k]) {
            k++;
            continue;
        }
        if (ss[i + k] > ss[j + k]) {
            i = i + k + 1;
            if (i <= j) i = j + 1;
        } else {
            j = j + k + 1;
            if (j <= i) j = i + 1;
        }
        k = 0;
    }
    return min(i, j);
}

int main() {
    string s;
    cin >> s;
    int idx = booth(s);
    string res = s.substr(idx) + s.substr(0, idx);
    cout << res << "\n";
    return 0;
}



// Suffix Array gives the order of all suffixes of a string. Read if interested.
// Ye code kuch waisa hi h but nlog^2(n) ka h jo TLE maarega iss question pe.... nlogn fastest implementation hota h

// Isme pehle sirf ek character consider krke order banao
// fir 2 character, fir 4 ... aise krte krte aur current ordering ka hi use krte krte ye kaam krna h

#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    cin >> s;
    int n = s.size();
	vector<int> ordering(n);
	vector<vector<int>> collec;
	collec.push_back(vector<int>());
	for(int i=0;i<n;i++) {
		collec[0].push_back(i);
		ordering[i] = s[i]-'a';
	}

	int p=0;
	while(p < n) {
		vector<int> next_ordering(n);
		vector<vector<int>> next_collec;
		int cumm = 0;
		for(int i=0;i<collec.size();i++) {
			set<int> st;
			for(int j:collec[i]) {
				st.insert(ordering[(j+p)%n]);
			}
			vector<int> temp(st.begin(), st.end());
			while(next_collec.size() < cumm + temp.size()) next_collec.push_back(vector<int>());
			
			for(int j:collec[i]) {
				next_ordering[j] = cumm + lower_bound(temp.begin(), temp.end(), ordering[(j+p)%n]) - temp.begin();
				next_collec[next_ordering[j]].push_back(j);
			}
			cumm += temp.size();
		}
		if(p==0) p++;
		else p <<= 1;
		collec = next_collec;
		ordering = next_ordering;
	}

	cout << s.substr(collec[0][0]) + s.substr(0, collec[0][0]) << endl;
    return 0;
}
