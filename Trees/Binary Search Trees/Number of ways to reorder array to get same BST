LC link: https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/

// Dekh ye ekdum intuitive solution h
// agar tree given ho to ans calculation to linear time me hoga
// but tree banane me O(n^2) worst case time ja skta h
// islie ye tarika na fail kr skta 
// O(n) solutions bhi h LC par baad me check kr lena
// filhal thoda complex lag rha tha

using ll = long long;
const int mod = 1e9+7;
class Node{
    public:
    int data;
    Node *left, *right;
    Node(int data) {
        this->data = data;
        left = right = nullptr;
    }
};
ll fact[1001], ifact[1001];
void insert(Node* root, int data) {
    Node* curr = root;
    Node* newNode = new Node(data);
    while(true) {
        if(curr->data > data) {
            if(!curr->left) {
                curr->left = newNode;
                return;
            } 
            else curr = curr->left;
        }
        else {
            if(!curr->right) {
                curr->right = newNode;
                return;
            } 
            else curr = curr->right;
        }
    }
}
// count, ways
pair<int,ll> calc(Node* root) {
    if(root == nullptr) return {0,1};
    pair<int,ll> left = calc(root->left);
    pair<int,ll> right = calc(root->right);

    pair<int,ll> ans;
    ans.second = (fact[left.first + right.first] * ifact[left.first])%mod;
    ans.second = (ans.second * ifact[right.first])%mod;
    ans.second = (ans.second * left.second)%mod;
    ans.second = (ans.second * right.second)%mod;
    ans.first  = left.first + right.first + 1;
    return ans;
}
ll bin_pow(ll x, int n) {
    ll ans = 1;
    while(n) {
        if(n&1) {
            n--;
            ans = (ans*x)%mod;
        }
        n>>=1;
        x = (x*x)%mod;
    }
    return ans;
}
int numOfWays(vector<int>& nums) {
    fact[0] = fact[1] = 1;
    for(int i=2;i<=1000;i++) {
        fact[i] = (i*fact[i-1])%mod;
    }
    ifact[1000] = bin_pow(fact[1000], mod-2);
    for(int i=999;i>=0;i--) {
        ifact[i] = ((i+1)*ifact[i+1])%mod;
    }
    int n = nums.size();
    Node* root = new Node(nums[0]);
    for(int i=1;i<n;i++) {
        insert(root, nums[i]);
    }
    return calc(root).second-1;
}

