CodeChef link: https://www.codechef.com/problems/UPDOTR

// Intuition:
// hmlog ke paas prefix maximas h to we will try to find the first position where the chef learns a dish
// shuru me hi check kr dia agar prefix_max[node] <= w then to ans 0
// else ans >= 1 hi hoga
// we are at the first position where he learns it
// now hops[i] is the number of times he learnt when he started from root with initial tastiness as tastiness[root] till he reached node 'i' (root = 1)
// suppose root se 'v' tk jaane me 'node' raaste me aaya
// to fir jab node se aage badhenge tab initial tastiness = prefix_max[node] leke hi aage badhenge na
// aur hmlog question me kaha pe initially logn time leke kuda die h? the topmost position where the prefix_max is greater than w
// to ab uss position pe prefix_max leke hi aage badha jayega
// ab iss question me binary lifting kyu chahiye tha?
// because topmost position find krne k lie given target node se hi upar ki taraf jaate na because root se to niche ke bhut saare paths h
// islie hmlog ko upar hi query krna tha
// hmesha na yar populate_parent alag se hi likhna
// yaha ek constraint h ki 1<=pi<=i-1 islie na dfs me bhi agar kroge to chal jayega kaam
// but baaki jagah ni chalega simple reason ki kisi bhi node ka kth row ke lie (k-1th) wala to hona chahye na available
// to wo available kaise hoga agar dfs hi ni hua h abhi tk waha
// aur same reason se hi k wala loop hmesha bahar rhega.... pehle k wala position sabka populate hoga
// then only k+1 ka hoga

#include <bits/stdc++.h>
using namespace std;
void dfs(int node, vector<vector<int>>&adj, vector<int>& tastiness, vector<int> &prefix_max, vector<int> &hops, vector<vector<int>> &parent){
    for(int i:adj[node]){
        prefix_max[i] = max(tastiness[i], prefix_max[node]);
        hops[i] = hops[node] + (prefix_max[node] < tastiness[i]);
        dfs(i, adj, tastiness, prefix_max, hops, parent);
    }
}
void populate_parent(int n, auto &parent) {
    int k = 1;
    while((1<<k) < n) {
        for(int i=1;i<=n;i++) {
            int mid = parent[k-1][i];
            if(mid!=-1) parent[k][i] = parent[k-1][mid];
        }
        k++;
    }
}
int solve(int node, int w, vector<int> &prefix_max, vector<int> &hops, vector<vector<int>> &parent) {
    int orig = node;
    for(int i=19;i>=0;i--) {
        int vp = parent[i][node];
        if(vp != -1 && prefix_max[vp] > w){
            node = vp;
        }
    }
    return 1 + hops[orig] - hops[node];
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
    int t;
    cin >> t;
    while(t--) {
        int n;
        cin >> n;
        vector<int> tastiness(n+1);
        for(int i=1;i<=n;i++) cin >> tastiness[i];
        vector<vector<int>> parent(20,vector<int>(n+1, -1));
        vector<vector<int>> adj(n+1);
        for(int i=2;i<=n;i++) {
            int x;
            cin >> x;
            adj[x].push_back(i);
            parent[0][i] = x;
        }
        vector<int> prefix_max(n+1);
        prefix_max[1] = tastiness[1];
        vector<int> hops(n+1, 0);
        dfs(1, adj, tastiness, prefix_max, hops, parent);
        populate_parent(n, parent);
        int q;
        cin >> q;
        int prev = 0;
        while(q--) {
            int v;cin >> v;
            int w;cin >> w;
            v = v ^ prev;
            w = w ^ prev;
            if(prefix_max[v] <= w) prev = 0;
            else prev = solve(v,w,prefix_max,hops,parent);
            cout << prev << "\n";
        }
    }
}
