CF link: https://codeforces.com/contest/2154/problem/D

// Simple intuition yahi h na
// hmlog ka goal h 
// ki cat trap na ho unintended region me plus cat die na kre
// to iske lie we will remove only leaves (isse trap wala goal achieved)
// ab to ensure cat does not die... even odd parity ka use krenge across levels
// Also, while removing we will ensure ki n ko na hata de baki koi bhi leaf ho to we will
// remove it


#include<bits/stdc++.h>
using namespace std;
#define int long long

void dfs(int node, int par, int lvl, auto &adj, auto &parent, auto &level) {
	parent[node] = par;
	level[node] = lvl;
	for(int el:adj[node]) {
		if(el==par) continue;
		dfs(el,node,lvl+1,adj,parent,level);
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	int t;
	cin >> t;
	while(t--) {
		int n;
		cin >> n;
		
		vector<vector<int>> adj(n+1);
		vector<int> degree(n+1, 0);
		for(int i=0;i<n-1;i++) {
			int a, b;
			cin >> a >> b;
			adj[a].push_back(b);
			adj[b].push_back(a);
			degree[a]++;
			degree[b]++;
		}

		vector<int> parent(n+1, -1), level(n+1);
		dfs(1,-1,0,adj,parent,level);

		queue<int> leaves;
		for(int i=1;i<=n;i++) {
			if(adj[i].size()==1) {
				leaves.push(i);
			}
		}
		
		vector<string> ans;
		int rem = 0;
		while(!leaves.empty()) {
			int curr = leaves.front();
			leaves.pop();
			if(curr ==  n) continue;
			
			if(level[curr]%2 == rem) {
				ans.push_back("1");
				rem = (rem+1)%2;
			}
			ans.push_back("2 " + to_string(curr));				
			ans.push_back("1");
			rem = (rem+1)%2;
			for(int el:adj[curr]) {
				degree[el]--;
				if(degree[el]==1) leaves.push(el);
			}
		}

		cout << ans.size() << "\n";
		for(string &s:ans) {
			cout << s << "\n";
		}
		cout << "\n";
	}
	return 0;
}
