LC link: https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/description/

// Dekh isme jo recursion h wo ek jagah aur use ho rha h thoda
// acche se dekh lo
// kind of number of topo sorts possible of a directed tree kuch 
// iss type ka h


class Solution {
public:
    using ll = long long;
    const int mod = 1e9+7;
    const int N = 1e5;
    ll fact[100001], ifact[100001];
    // count, ways
    pair<int,ll> helper(int node, int par, auto &adj) {
        ll ans = 1;
        int count = 0;
        for(int el:adj[node]) {
            if(el==par) continue;
            pair<int,ll> val = helper(el, node, adj);
            ans = (ans * val.second)%mod;
            ans = (ans * ifact[val.first])%mod;
            count += val.first;
        }
        ans = (ans*fact[count])%mod;
        return {count+1, ans};
    }
    ll bin_pow(ll x, int n) {
        ll ans = 1;
        while(n) {
            if(n&1) {
                n--;
                ans = (ans*x)%mod;
            }
            x = (x*x)%mod;
            n>>=1;
        }
        return ans;
    }
    int waysToBuildRooms(vector<int>& prevRoom) {
        fact[0] = fact[1] = 1;
        for(int i=2;i<=N;i++) {
            fact[i] =  (i*fact[i-1])%mod;
        }
        ifact[N] = bin_pow(fact[N], mod-2);
        for(int i=N-1;i>=0;i--) {
            ifact[i] = ((i+1)*ifact[i+1])%mod;
        }
        int n = prevRoom.size();
        vector<vector<int>> adj(n);
        for(int i=1;i<n;i++) {
            adj[prevRoom[i]].push_back(i);
        }
        return helper(0,-1,adj).second;
    }
};

